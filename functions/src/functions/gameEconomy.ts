import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import { SettleRoundRequest, LedgerEntry } from "../types";



/**
 * settleGameRound
 * 
 * Handles the distribution of the pot and rake at the end of a game round.
 * 
 * Economic Model:
 * - Rake: 8% of the Total Pot.
 * - Winner Prize: Total Pot - Rake.
 * 
 * Rake Distribution (Pro-rated based on player contribution):
 * - Platform: 60%
 * - Club: 30% (if player belongs to a club)
 * - Seller: 10% (if player belongs to a seller)
 * 
 * Atomicity:
 * - Uses Firestore Transaction to ensure all balance updates and ledger entries happen or fail together.
 */
export const settleGameRound = async (data: SettleRoundRequest, context: functions.https.CallableContext) => {
    const db = admin.firestore();
    // 1. Validation
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }

    const { potTotal, winnerUid, playersInvolved, gameId } = data;

    if (!potTotal || !winnerUid || !playersInvolved || playersInvolved.length === 0) {
        throw new functions.https.HttpsError('invalid-argument', 'Missing required parameters.');
    }

    // 2. Calculate Rake and Prize
    const RAKE_PERCENTAGE = 0.08;
    const totalRake = potTotal * RAKE_PERCENTAGE;
    const winnerPrize = potTotal - totalRake;

    // 3. Prepare Distribution Data
    // We need to calculate how much rake each player generated and where it goes.
    // We will aggregate updates to minimize reads/writes within the transaction.

    const updates = {
        platformRake: 0,
        clubUpdates: new Map<string, number>(),   // clubId -> amountToAdd
        sellerUpdates: new Map<string, number>()  // sellerId -> amountToAdd
    };

    const ledgerEntries: LedgerEntry[] = [];
    const timestamp = admin.firestore.Timestamp.now();

    for (const player of playersInvolved) {
        // Calculate the portion of the pot this player contributed
        const contributionRatio = player.betAmount / potTotal;

        // Calculate the rake generated by this specific player
        const playerRake = totalRake * contributionRatio;

        // Distribute this player's rake
        const platformShare = playerRake * 0.60;
        const clubShare = playerRake * 0.30;
        const sellerShare = playerRake * 0.10;

        // Platform always gets its share
        updates.platformRake += platformShare;

        // Club Share
        if (player.clubId) {
            const currentClubAmount = updates.clubUpdates.get(player.clubId) || 0;
            updates.clubUpdates.set(player.clubId, currentClubAmount + clubShare);

            ledgerEntries.push({
                type: 'RAKE_DISTRIBUTION',
                amount: clubShare,
                source: `game_${gameId}_player_${player.uid}`,
                destination: `club_${player.clubId}`,
                description: `Rake share (30%) from player ${player.uid} in game ${gameId}`,
                timestamp: timestamp
            });
        } else {
            // If no club, Platform takes the club's share to prevent money loss
            updates.platformRake += clubShare;
        }

        // Seller Share
        if (player.sellerId) {
            const currentSellerAmount = updates.sellerUpdates.get(player.sellerId) || 0;
            updates.sellerUpdates.set(player.sellerId, currentSellerAmount + sellerShare);

            ledgerEntries.push({
                type: 'RAKE_DISTRIBUTION',
                amount: sellerShare,
                source: `game_${gameId}_player_${player.uid}`,
                destination: `seller_${player.sellerId}`,
                description: `Rake share (10%) from player ${player.uid} in game ${gameId}`,
                timestamp: timestamp
            });
        } else {
            // If no seller, Platform takes the seller's share
            updates.platformRake += sellerShare;
        }
    }

    // Add Platform Ledger Entry
    ledgerEntries.push({
        type: 'RAKE_DISTRIBUTION',
        amount: updates.platformRake,
        source: `game_${gameId}`,
        destination: 'platform_wallet',
        description: `Total Platform Rake (60% + undistributed) for game ${gameId}`,
        timestamp: timestamp
    });

    // Add Winner Prize Ledger Entry
    ledgerEntries.push({
        type: 'WIN_PRIZE',
        amount: winnerPrize,
        source: `game_${gameId}`,
        destination: `user_${winnerUid}`,
        description: `Winner prize for game ${gameId}`,
        timestamp: timestamp
    });

    // 4. Execute Atomic Transaction
    try {
        await db.runTransaction(async (transaction) => {
            // --- READS ---

            // Read Winner
            const winnerRef = db.collection('users').doc(winnerUid);
            const winnerDoc = await transaction.get(winnerRef);
            if (!winnerDoc.exists) {
                throw new functions.https.HttpsError('not-found', `Winner user ${winnerUid} not found.`);
            }

            // Read System Wallet
            const systemWalletRef = db.collection('system_wallets').doc('platform');
            const systemWalletDoc = await transaction.get(systemWalletRef);

            // Read Clubs
            const clubRefs: FirebaseFirestore.DocumentReference[] = [];
            updates.clubUpdates.forEach((_, clubId) => {
                clubRefs.push(db.collection('clubs').doc(clubId));
            });
            const clubDocs = await transaction.getAll(...clubRefs);

            // Read Sellers
            const sellerRefs: FirebaseFirestore.DocumentReference[] = [];
            updates.sellerUpdates.forEach((_, sellerId) => {
                sellerRefs.push(db.collection('sellers').doc(sellerId));
            });
            const sellerDocs = await transaction.getAll(...sellerRefs);

            // --- WRITES ---

            // Update Winner Balance
            const currentWinnerCredits = winnerDoc.data()?.credits || 0;
            transaction.update(winnerRef, {
                credits: currentWinnerCredits + winnerPrize
            });

            // Update System Wallet
            if (!systemWalletDoc.exists) {
                // Create if doesn't exist
                transaction.set(systemWalletRef, {
                    id: 'platform',
                    balance: updates.platformRake,
                    updatedAt: timestamp
                });
            } else {
                const currentSystemBalance = systemWalletDoc.data()?.balance || 0;
                transaction.update(systemWalletRef, {
                    balance: currentSystemBalance + updates.platformRake,
                    updatedAt: timestamp
                });
            }

            // Update Clubs
            clubDocs.forEach((doc) => {
                if (doc.exists) {
                    const clubId = doc.id;
                    const amountToAdd = updates.clubUpdates.get(clubId) || 0;
                    const currentBalance = doc.data()?.walletBalance || 0;
                    transaction.update(doc.ref, {
                        walletBalance: currentBalance + amountToAdd
                    });
                }
            });

            // Update Sellers
            sellerDocs.forEach((doc) => {
                if (doc.exists) {
                    const sellerId = doc.id;
                    const amountToAdd = updates.sellerUpdates.get(sellerId) || 0;
                    const currentBalance = doc.data()?.walletBalance || 0;
                    transaction.update(doc.ref, {
                        walletBalance: currentBalance + amountToAdd
                    });
                }
            });

            // Write Ledger Entries
            const ledgerRef = db.collection('financial_ledger');
            ledgerEntries.forEach((entry) => {
                const newEntryRef = ledgerRef.doc();
                transaction.set(newEntryRef, entry);
            });
        });

        return { success: true, message: 'Game round settled successfully.', gameId };

    } catch (error) {
        console.error('Transaction failure:', error);
        throw new functions.https.HttpsError('internal', 'Transaction failed: ' + error);
    }
};
